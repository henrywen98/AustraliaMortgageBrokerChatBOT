from utils.unified_client import UnifiedAIClient
from utils.knowledge_base import KnowledgeBase
from utils.web_search import WebS    def generate_response(self, user_input: str, language: str = "ä¸­æ–‡", mode: str = "simple", 
                         use_web_search: bool = False, **kwargs) -> str:
        """ç”ŸæˆAIå›å¤ï¼ˆæ”¯æŒç½‘ç»œæœç´¢å¢å¼ºï¼‰
        
        Args:
            user_input: ç”¨æˆ·è¾“å…¥
            language: å›ç­”è¯­è¨€
            mode: å›ç­”æ¨¡å¼
            use_web_search: æ˜¯å¦å¯ç”¨ç½‘ç»œæœç´¢
        """
        
        # å¦‚æœå¯ç”¨ç½‘ç»œæœç´¢ä¸”ä½¿ç”¨Deepseek
        if use_web_search and self.api_client.provider == "deepseek":
            try:
                search_response = self.deepseek_web_search.search_and_answer(
                    user_input, 
                    search_enabled=True, 
                    num_results=3
                )
                
                # æ ¼å¼åŒ–å¸¦æ¥æºçš„å›ç­”
                answer = search_response["answer"]
                
                # æ·»åŠ æ¥æºä¿¡æ¯
                if search_response.get("sources"):
                    sources_text = "\n\nğŸ“š ä¿¡æ¯æ¥æºï¼š"
                    for i, source in enumerate(search_response["sources"], 1):
                        sources_text += f"\n[{i}] {source['title']} - {source['source']}"
                        sources_text += f"\n    ğŸ”— {source['url']}"
                    
                    answer += sources_text
                
                return answer
                
            except Exception as e:
                # æœç´¢å¤±è´¥æ—¶å›é€€åˆ°æ™®é€šæ¨¡å¼
                print(f"ç½‘ç»œæœç´¢å¤±è´¥ï¼Œä½¿ç”¨æ™®é€šæ¨¡å¼: {e}")
                return self._generate_normal_response(user_input, language, mode, **kwargs)
        
        # æ™®é€šæ¨¡å¼ï¼ˆä¸ä½¿ç”¨ç½‘ç»œæœç´¢ï¼‰
        return self._generate_normal_response(user_input, language, mode, **kwargs)
    
    def _generate_normal_response(self, user_input: str, language: str = "ä¸­æ–‡", mode: str = "simple", **kwargs) -> str:
        """ç”Ÿæˆæ™®é€šå›å¤ï¼ˆåŸæœ‰é€»è¾‘ï¼‰"""hClient, DeepseekWebSearch
from pathlib import Path
from typing import List, Dict, Any
import textwrap
import datetime as _dt
from config import RAG_ENABLED, RAG_TOP_K, MODEL_NAME, MODEL_PROVIDER


def _load_prompt(language: str) -> str:
    """Load system prompt text from prompts/ directory by language.
    Defaults to Chinese prompt if specific language file is missing.
    """
    base = Path(__file__).resolve().parents[1] / "prompts"
    if language == "English":
        path = base / "broker_system.en.md"
    else:
        path = base / "broker_system.zh.md"

    if path.exists():
        return path.read_text(encoding="utf-8").strip()

    # Fallback minimal prompt (Chinese)
    return (
        "ä½ æ˜¯æ¾³å¤§åˆ©äºšæˆ¿è´·ä¸­ä»‹AIåŠ©æ‰‹ï¼Œåªèƒ½ç”¨ä¸­æ–‡å›ç­”ã€‚"
        "è¯·ä¸¥æ ¼æŒ‰ä»¥ä¸‹ç»“æ„è¾“å‡ºï¼šå…ˆâ€˜æ¨ç†è¿‡ç¨‹ï¼ˆç®€è¦è¦ç‚¹ï¼‰â€™ï¼Œåâ€˜ç»“è®ºâ€™ã€‚"
    )


class SimpleRAG:
    """ChromaDB-backed retrieval used as optional RAG component with lazy loading."""

    def __init__(self, enabled: bool = False, top_k: int = 3):
        self.enabled = enabled
        self.top_k = max(1, top_k)
        self.kb: KnowledgeBase | None = None
        self._kb_initialized = False
        # ä¸åœ¨åˆå§‹åŒ–æ—¶å°±åˆ›å»ºæ•°æ®åº“è¿æ¥ï¼Œè€Œæ˜¯åœ¨é¦–æ¬¡ä½¿ç”¨æ—¶åˆ›å»º

    def _ensure_kb_initialized(self):
        """æ‡’åŠ è½½ï¼šä»…åœ¨é¦–æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–çŸ¥è¯†åº“"""
        if not self.enabled:
            return
        
        if not self._kb_initialized:
            try:
                print("ğŸ” é¦–æ¬¡ä½¿ç”¨RAGï¼Œæ­£åœ¨åˆå§‹åŒ–çŸ¥è¯†åº“...")
                self.kb = KnowledgeBase()
                self._kb_initialized = True
                print("âœ… çŸ¥è¯†åº“åˆå§‹åŒ–å®Œæˆ")
            except Exception as e:
                print(f"âš ï¸ çŸ¥è¯†åº“åˆå§‹åŒ–å¤±è´¥: {e}")
                self.kb = None
                self._kb_initialized = True

    def retrieve(self, query: str, k: int | None = None) -> List[Dict[str, Any]]:
        if not self.enabled:
            return []
        
        self._ensure_kb_initialized()
        if not self.kb:
            return []
            
        return self.kb.search(query, top_k=k or self.top_k)

    def format_context(self, chunks: List[Dict[str, Any]]) -> str:
        if not chunks:
            return ""
        lines = ["æ£€ç´¢åˆ°çš„å¯èƒ½ç›¸å…³èµ„æ–™ï¼ˆä»…ä¾›å‚è€ƒï¼‰ï¼š"]
        for i, ch in enumerate(chunks, 1):
            src = ch.get("source") or "unknown"
            content = (ch.get("content") or "").strip()
            content = textwrap.shorten(content, width=600, placeholder=" â€¦")
            lines.append(f"[{i}] æ¥æº: {src}\n{content}")
        lines.append(
            "è¯·ä¼˜å…ˆå‚è€ƒä¸Šè¿°èµ„æ–™å›ç­”ï¼Œå¼•ç”¨æ—¶è¯·ç”¨ [åºå·] æ ‡æ³¨æ¥æºï¼›åœ¨ä¸ç¡®å®šæ—¶æç¤ºæ ¸éªŒï¼Œä¸å¾—ç¼–é€ æœªè¯å®çš„åˆ©ç‡æˆ–æ”¿ç­–ã€‚"
        )
        return "\n\n".join(lines)

    def format_sources(self, chunks: List[Dict[str, Any]]) -> str:
        """Format retrieval results as numbered source list."""
        if not chunks:
            return ""
        lines = []
        for i, ch in enumerate(chunks, 1):
            src = ch.get("source") or "unknown"
            lines.append(f"[{i}] {src}")
        return "\n".join(lines)


class AustralianMortgageBroker:
    """æ¾³å¤§åˆ©äºšæŠµæŠ¼è´·æ¬¾ç»çºªäººAIåŠ©æ‰‹ï¼ˆæ”¯æŒå¤šæä¾›å•† + ç½‘ç»œæœç´¢ï¼‰"""

    def __init__(self):
        self.api_client = UnifiedAIClient(model=MODEL_NAME, provider=MODEL_PROVIDER)
        self.conversation_history = []
        self.rag = SimpleRAG(enabled=RAG_ENABLED, top_k=RAG_TOP_K)
        
        # åˆå§‹åŒ–ç½‘ç»œæœç´¢åŠŸèƒ½
        self.web_search_client = WebSearchClient()
        self.deepseek_web_search = DeepseekWebSearch(self.api_client, self.web_search_client)
    
    def get_available_providers(self):
        """è·å–å¯ç”¨çš„AIæä¾›å•†"""
        return ["openai", "deepseek"]

    def set_provider(self, provider: str):
        """åˆ‡æ¢AIæä¾›å•†"""
        try:
            if provider.lower() == "deepseek":
                self.api_client = UnifiedAIClient(model="deepseek-chat", provider="deepseek")
            else:
                self.api_client = UnifiedAIClient(model="gpt-4o-mini", provider="openai")
            return True
        except Exception:
            return False

    def get_provider_name(self, provider: str):
        """è·å–æä¾›å•†æ˜¾ç¤ºåç§°"""
        names = {
            "openai": "OpenAI",
            "deepseek": "Deepseek"
        }
        return names.get(provider.lower(), "Unknown")

    def test_provider_connection(self):
        return self.api_client.test_connection()
    
    def generate_response(self, user_input: str, language: str = "ä¸­æ–‡", mode: str = "simple", **kwargs) -> str:
        """ç”ŸæˆAIå›å¤ï¼ˆç»“æ„åŒ–ï¼šå…ˆâ€œæ¨ç†è¿‡ç¨‹ï¼ˆç®€è¦è¦ç‚¹ï¼‰â€ï¼Œåâ€œç»“è®ºâ€ï¼‰ã€‚
        System Prompt å¤–ç½®ï¼Œé»˜è®¤ä¸­æ–‡ï¼›è‹¥ä¼ å…¥ English åˆ™åŠ è½½è‹±æ–‡æç¤ºè¯æ–‡ä»¶ã€‚
        """

        # æ„å»ºç³»ç»Ÿæç¤ºï¼ˆä»æ–‡ä»¶åŠ è½½ï¼Œä¾¿äºç»´æŠ¤ï¼‰
        system_prompt = _load_prompt(language)

        # å¯é€‰ï¼šRAG æ£€ç´¢ä¸Šä¸‹æ–‡ï¼ˆä¸å½±å“åŸå§‹é€»è¾‘ï¼Œé»˜è®¤å…³é—­ï¼‰
        rag_context = ""
        rag_chunks: List[Dict[str, Any]] = []
        if self.rag.enabled:
            try:
                rag_chunks = self.rag.retrieve(user_input, k=self.rag.top_k)
                rag_context = self.rag.format_context(rag_chunks)
            except Exception:
                rag_context = ""
                rag_chunks = []

        # æ„å»ºæ¶ˆæ¯åˆ—è¡¨
        messages = [{"role": "system", "content": system_prompt}]
        if rag_context:
            messages.append({"role": "system", "content": rag_context})
        
        # æ·»åŠ å†å²å¯¹è¯ï¼ˆæœ€è¿‘5è½®ï¼‰
        for msg in self.conversation_history[-10:]:
            messages.append(msg)
        
        # æ·»åŠ å½“å‰ç”¨æˆ·è¾“å…¥ï¼ˆé™„åŠ æ—¶é—´æˆ³åœ¨å†…éƒ¨è®°å½•ï¼Œé¿å…æ±¡æŸ“æç¤ºï¼‰
        messages.append({"role": "user", "content": user_input})
        
        try:
            # ç”Ÿæˆå›å¤
            response = self.api_client.generate_response(
                messages=messages,
                max_tokens=1500
            )
            
            # æ›´æ–°å¯¹è¯å†å²ï¼ˆå¸¦æ—¶é—´æˆ³ï¼‰
            ts = _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.conversation_history.append({"role": "user", "content": user_input, "ts": ts})
            self.conversation_history.append({"role": "assistant", "content": response, "ts": ts})
            
            # ä¿æŒå†å²é•¿åº¦åœ¨åˆç†èŒƒå›´å†…
            if len(self.conversation_history) > 20:
                self.conversation_history = self.conversation_history[-20:]
            
            # ä¿éšœä¸­æ–‡ä¸ç»“æ„ï¼šè‹¥æ¨¡å‹æœªæŒ‰ç»“æ„è¿”å›ï¼Œåšè½»é‡å…œåº•æ ¼å¼åŒ–
            content = response.strip()
            if "æ¨ç†è¿‡ç¨‹" not in content or "ç»“è®º" not in content:
                content = (
                    "æ¨ç†è¿‡ç¨‹ï¼ˆç®€è¦è¦ç‚¹ï¼‰ï¼š\n"
                    "- æ ¹æ®æé—®å†…å®¹è¿›è¡Œæ”¿ç­–ä¸æµç¨‹åŒ¹é…\n"
                    "- ç»“åˆè´·æ¬¾ç›®çš„ã€èº«ä»½ã€æ”¶å…¥ä¸è´Ÿå€ºç­‰\n"
                    "- å‚è€ƒå„è´·æ–¹å…¬å¼€æ”¿ç­–å¹¶æç¤ºå·®å¼‚\n"
                    "- å¦‚ä¿¡æ¯ä¸è¶³ï¼Œå»ºè®®è¡¥å……å…³é”®ç»†èŠ‚\n"
                    f"\nç»“è®ºï¼š\n{content}"
                )
            if rag_chunks:
                sources_text = self.rag.format_sources(rag_chunks)
                if sources_text:
                    content = f"{content}\n\nå‚è€ƒæ¥æºï¼š\n{sources_text}"
            return content
            
        except Exception as e:
            error_msg = f"ç”Ÿæˆå›å¤æ—¶å‡ºç°é”™è¯¯: {str(e)}"
            if language == "English":
                error_msg = f"Error generating response: {str(e)}"
            return error_msg
